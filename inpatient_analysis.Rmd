---
title: "inpatient_analysis"
output: html_document
---

```{r} 

# ── 1. Read raw data ─────────────────────────────────────────────────────────

library(tidyverse)
library(janitor)
library(lubridate)
library(glue)
library(labelled)
library(haven)

```

```{r}

# ── 2. Drop columns that are 100 % NA (log them) ────────────────────────────

inpt_claims_raw <- read_csv("data/inpatient_claims_raw.csv",
                            col_types = cols(
                              DESYNPUF_ID = col_character(),
                              CLM_ID      = col_character()
                            ))

before_cols <- names(inpt_claims_raw)

inpt_claims <- inpt_claims_raw %>%
  remove_constant(na.rm = FALSE)

after_cols <- names(inpt_claims)

removed <- setdiff(before_cols, after_cols)
if (length(removed) > 0) {
  message(glue(
    "Removed columns: {paste(removed, collapse = ', ')}"
    ))
} else {
  message("No constant columns removed.")
}

```
 
```{r}

# ── 3. Standardize names & basic types ──────────────────────────────────────

inpt_claims <- inpt_claims %>%
  clean_names() %>%
  mutate(
    admit_date     = ymd(as.character(clm_admsn_dt)),
    from_date      = ymd(as.character(clm_from_dt)),
    thru_date      = ymd(as.character(clm_thru_dt)),
    discharge_date = ymd(as.character(nch_bene_dschrg_dt)),
    drg_code       = factor(clm_drg_cd),
  )

```

```{r}

# ── 4a. Identify a bill-type column, if present ──────────────────────────────

preferred_bill_vars <- c("bill_type", "clm_type_cd", "tob")

bill_type_vars <- preferred_bill_vars[preferred_bill_vars %in% names(inpt_claims)]


if (length(bill_type_vars) == 0) {
  
  # File has no bill-type field (e.g., DE-SynPUF)
  # • Treat every claim as a final-action bill (already the CMS default).
  # • Create a neutral rank of 2 so later arrange()/de-dupe logic works.
  inpt_claims <- inpt_claims %>%
    mutate(
      tob_first = NA_character_,           # placeholder, keeps schema consistent
      tob_last  = NA_character_,           # placeholder, keeps schema consistent
      tob_rank  = 2L                       # 2 = ordinary final bill
    )
} else {
  
  # Use the first preferred column as the authoritative source
  primary_bt <- bill_type_vars[1]
  
  # If there’s a second column, check that it matches (after padding)
  if (length(bill_type_vars) == 2) {
    secondary_bt <- bill_type_vars[2]
    
    agree <- all(
      str_pad(inpt_claims[[primary_bt]], 3, pad = "0") ==
        str_pad(inpt_claims[[secondary_bt]], 3, pad = "0"),
      na.rm = TRUE
    )
    
    if (!agree) 
      warning(glue(
        "Bill-type columns '{primary_bt}' and '{secondary_bt}' ",
        "do not match for at least one record...please investigate."
      )
    )
  }
  
  # Convert the selected bill-type field (e.g, BILL_TYPE, CLM_TYPE_CD, TOB)
  # to a 3-character string, then extract its 3rd digit:
  #   • bill_type_chr : zero-padded literal (e.g. "114")
  #   • tob_last      : frequency digit (1 = final, 4 = final-interim, 7 = replacement)
  inpt_claims <- inpt_claims %>%
    mutate(
      bill_type_chr = str_pad(as.character(!!sym(primary_bt)), 3, pad = "0"),
      tob_first     = substr(bill_type_chr, 1, 1),    # institutional type (1 = inpatient)
      tob_last      = substr(bill_type_chr, 3, 3),
      
      # Numeric ranking (Lower = better)
      tob_rank = case_when(
        tob_last == "7"             ~ 1,  # replacement/adjusted
        tob_last %in% c("4", "1")   ~ 2,  # final-interim OR admit-thru-discharge final
        TRUE                        ~ 3   # interim (2/3), void (8), no-pay (0)
      )
    ) %>%
    
    # Filter to inpatient claims only
    filter(tob_first == "1")
}

```

```{r}

# ── 4b.  De-duplicate on CLM_ID, keeping only the best-ranked version ────────
#  1. Sort so “best” rows rise to the top of each CLM_ID group:
#       • lowest tob_rank first  (1 = replacement, 2 = final, 3 = interim/void)
#       • if ranks tie, pick the row with the latest service span
#  2. `distinct()` then keeps that first row and drops the rest.

inpt_claims <- inpt_claims %>% 
  arrange(
    clm_id,                                                           
    tob_rank,                                                         
    desc(pmax(discharge_date, thru_date, na.rm = TRUE))     
  ) %>% 
  distinct(clm_id, .keep_all = TRUE)

```

```{r}

# ── 5. Calculate Length-of-Stay (LOS) ───────────────────────────────────────

inpt_claims <- inpt_claims %>% 
  mutate(
    los = case_when(
      tob_rank <= 2 & !is.na(discharge_date) ~ as.integer(discharge_date - admit_date),
      tob_rank <= 2 &  is.na(discharge_date) ~ as.integer(thru_date      - admit_date),
      TRUE                                   ~ NA_integer_
    )
  )

```

```{r}

# ── 6. Label key variables for SPSS / Haven export ──────────────────────────

# Core stay metrics
var_label(inpt_claims$los)                         <- "Length of stay (days)"

# Stay-level dates
var_label(inpt_claims$admit_date)                  <- "Admission date"
var_label(inpt_claims$discharge_date)              <- "Discharge date"

# Statement-covers period
var_label(inpt_claims$from_date)                   <- "Claim FROM date (first service on this bill)"
var_label(inpt_claims$thru_date)                   <- "Claim THRU date (last service on this bill)"

# Type-of-Bill fields (may be NA in DE-SynPUF)
var_label(inpt_claims$tob_first)                   <- "Type-of-Bill first digit (1 = inpatient facility, others = excluded)"
var_label(inpt_claims$tob_last)                    <- "Bill frequency digit (1 = final, 4 = final-interim, 7 = replacement; NA in SynPUF)"
var_label(inpt_claims$tob_rank)                    <- "Priority rank for duplicate resolution (1 = replacement, 2 = final, 3 = interim/void)"

# Other claim descriptors
var_label(inpt_claims$drg_code)                    <- "Diagnosis-Related Group (DRG)"

```

```{r}

# ── 7. Save cleaned data sets ────────────────────────────────────────────────

write_csv(inpt_claims, "data/inpatient_claims_clean.csv")
write_sav(inpt_claims, "data/inpatient_claims_clean.sav")

```
